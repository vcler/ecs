// generated by claude, which was much more willing to spit out tests than chatgpt

#include <doctest.h>
#include <ecs.hpp>
#include <stdexcept>
#include <vector>
#include <algorithm>

// Test components
struct position {
    float x, y;
    position(float x = 0.0f, float y = 0.0f) : x(x), y(y) {}
    bool operator==(const position& other) const {
        return x == other.x && y == other.y;
    }
};

struct velocity {
    float dx, dy;
    velocity(float dx = 0.0f, float dy = 0.0f) : dx(dx), dy(dy) {}
    bool operator==(const velocity& other) const {
        return dx == other.dx && dy == other.dy;
    }
};

struct health {
    float current, max;
    ecs::handle_type owner{};  // Fat component
    health(float current = 100.0f, float max = 100.0f) 
        : current(current), max(max) {}
};

struct name {
    std::string value;
    name(const std::string& n = "") : value(n) {}
};

struct damage {
    float amount;
    ecs::handle_type owner{};  // Fat component
    damage(float amt = 0.0f) : amount(amt) {}
};

// Singleton for testing
struct world_time {
    float delta_time;
    float total_time;
    world_time(float dt = 0.016f, float total = 0.0f) 
        : delta_time(dt), total_time(total) {}
};

TEST_CASE("Entity Creation and Basic Operations") {
    ecs::registry reg;
    
    SUBCASE("Create entity with single component") {
        auto ent = ecs::create(reg, position(10.0f, 20.0f));
        CHECK(ent != ecs::handle_type{});
        
        auto& pos = ecs::get<position>(reg, ent);
        CHECK(pos.x == 10.0f);
        CHECK(pos.y == 20.0f);
    }
    
    SUBCASE("Create entity with multiple components") {
        auto ent = ecs::create(reg, position(5.0f, 15.0f), velocity(1.0f, -1.0f));
        
        auto& pos = ecs::get<position>(reg, ent);
        auto& vel = ecs::get<velocity>(reg, ent);
        
        CHECK(pos.x == 5.0f);
        CHECK(pos.y == 15.0f);
        CHECK(vel.dx == 1.0f);
        CHECK(vel.dy == -1.0f);
    }
    
    SUBCASE("Create multiple entities") {
        auto ent1 = ecs::create(reg, position(0.0f, 0.0f));
        auto ent2 = ecs::create(reg, position(10.0f, 10.0f));
        auto ent3 = ecs::create(reg, velocity(1.0f, 1.0f));
        
        CHECK(ent1 != ent2);
        CHECK(ent2 != ent3);
        CHECK(ent1 != ent3);
    }
}

TEST_CASE("Component Addition via Emplace") {
    ecs::registry reg;
    auto ent = ecs::create(reg, position(0.0f, 0.0f));
    
    SUBCASE("Emplace with constructed component") {
        velocity vel(5.0f, -5.0f);
        auto& added_vel = ecs::emplace(reg, ent, std::move(vel));
        
        CHECK(added_vel.dx == 5.0f);
        CHECK(added_vel.dy == -5.0f);
        
        auto& retrieved_vel = ecs::get<velocity>(reg, ent);
        CHECK(retrieved_vel.dx == 5.0f);
        CHECK(retrieved_vel.dy == -5.0f);
    }
    
    SUBCASE("Emplace with constructor arguments") {
        auto& health_comp = ecs::emplace<health>(reg, ent, 75.0f, 100.0f);
        
        CHECK(health_comp.current == 75.0f);
        CHECK(health_comp.max == 100.0f);
        CHECK(health_comp.owner == ent);  // Should be set automatically
    }
    
    SUBCASE("Emplace duplicate component should throw") {
        ecs::emplace<velocity>(reg, ent, 1.0f, 1.0f);
        
        CHECK_THROWS_AS(ecs::emplace<velocity>(reg, ent, 2.0f, 2.0f), std::logic_error);
    }
}

TEST_CASE("Component Retrieval and Errors") {
    ecs::registry reg;
    auto ent = ecs::create(reg, position(1.0f, 2.0f), velocity(3.0f, 4.0f));
    
    SUBCASE("Get existing components") {
        auto& pos = ecs::get<position>(reg, ent);
        auto& vel = ecs::get<velocity>(reg, ent);
        
        CHECK(pos.x == 1.0f);
        CHECK(pos.y == 2.0f);
        CHECK(vel.dx == 3.0f);
        CHECK(vel.dy == 4.0f);
    }
    
    SUBCASE("Get non-existing component should throw") {
        CHECK_THROWS_AS(ecs::get<health>(reg, ent), std::invalid_argument);
    }
    
    SUBCASE("Get from invalid entity should throw") {
        ecs::handle_type invalid_ent{};  // Default constructed handle
        CHECK_THROWS_AS(ecs::get<position>(reg, invalid_ent), std::out_of_range);
    }
}

TEST_CASE("Entity Destruction") {
    ecs::registry reg;
    
    SUBCASE("Destroy entity with all components specified") {
        auto ent = ecs::create(reg, position(0.0f, 0.0f), velocity(1.0f, 1.0f));
        
        // Should not throw
        ecs::destroy<position, velocity>(reg, ent);
        
        // Access should now throw
        CHECK_THROWS_AS(ecs::get<position>(reg, ent), std::out_of_range);
        CHECK_THROWS_AS(ecs::get<velocity>(reg, ent), std::out_of_range);
    }
    
    SUBCASE("Destroy entity with missing component specification") {
        auto ent = ecs::create(reg, position(0.0f, 0.0f), velocity(1.0f, 1.0f));
        
        // Only specify position, not velocity - according to docs this should
        // leave velocity component accessible
        ecs::destroy<position>(reg, ent);
        
        CHECK_THROWS_AS(ecs::get<position>(reg, ent), std::out_of_range);
        // velocity should still exist according to the documentation
        // (though this behavior might be implementation-dependent)
    }
    
    SUBCASE("Destroy non-existing entity should throw") {
        ecs::handle_type invalid_ent{};
        CHECK_THROWS_AS(ecs::destroy<position>(reg, invalid_ent), std::out_of_range);
    }
    
    SUBCASE("Destroy with wrong component types should throw") {
        auto ent = ecs::create(reg, position(0.0f, 0.0f));
        CHECK_THROWS_AS(ecs::destroy<velocity>(reg, ent), std::invalid_argument);
    }
}

TEST_CASE("Component Range Iteration") {
    ecs::registry reg;
    
    // Create test entities
    auto ent1 = ecs::create(reg, position(1.0f, 1.0f));
    auto ent2 = ecs::create(reg, position(2.0f, 2.0f), velocity(1.0f, 0.0f));
    auto ent3 = ecs::create(reg, position(3.0f, 3.0f), velocity(0.0f, 1.0f));
    ecs::create(reg, velocity(-1.0f, -1.0f));  // No position
    
    SUBCASE("Single component range") {
        std::vector<position> positions;
        for (auto& pos : ecs::range<position>(reg)) {
            positions.push_back(pos);
        }
        
        CHECK(positions.size() == 3);
        
        // Sort for predictable comparison
        std::sort(positions.begin(), positions.end(), 
            [](const position& a, const position& b) { return a.x < b.x; });
            
        CHECK(positions[0] == position(1.0f, 1.0f));
        CHECK(positions[1] == position(2.0f, 2.0f));
        CHECK(positions[2] == position(3.0f, 3.0f));
    }
    
    SUBCASE("Multi-component tuple range") {
        std::vector<std::pair<position, velocity>> entities;
        for (auto& [pos, vel] : ecs::range<position, velocity>(reg)) {
            entities.push_back({pos, vel});
        }
        
        CHECK(entities.size() == 2);  // Only ent2 and ent3 have both components
        
        // Sort for predictable comparison
        std::sort(entities.begin(), entities.end(),
            [](const auto& a, const auto& b) { return a.first.x < b.first.x; });
            
        CHECK(entities[0].first == position(2.0f, 2.0f));
        CHECK(entities[0].second == velocity(1.0f, 0.0f));
        CHECK(entities[1].first == position(3.0f, 3.0f));
        CHECK(entities[1].second == velocity(0.0f, 1.0f));
    }
    
    SUBCASE("Range modification") {
        // Modify components through range iteration
        for (auto& pos : ecs::range<position>(reg)) {
            pos.x *= 2.0f;
            pos.y *= 2.0f;
        }
        
        auto& pos1 = ecs::get<position>(reg, ent1);
        auto& pos2 = ecs::get<position>(reg, ent2);
        auto& pos3 = ecs::get<position>(reg, ent3);
        
        CHECK(pos1 == position(2.0f, 2.0f));
        CHECK(pos2 == position(4.0f, 4.0f));
        CHECK(pos3 == position(6.0f, 6.0f));
    }
}

TEST_CASE("Singleton Management") {
    ecs::registry reg;
    
    SUBCASE("Create and retrieve singleton") {
        auto& time = ecs::singleton(reg, world_time(0.016f, 10.0f));
        
        CHECK(time.delta_time == 0.016f);
        CHECK(time.total_time == 10.0f);
    }
    
    SUBCASE("Retrieve existing singleton") {
        // Create first
        ecs::singleton(reg, world_time(0.020f, 5.0f));
        
        // Retrieve existing
        auto& time = ecs::singleton<world_time>(reg);
        CHECK(time.delta_time == 0.020f);
        CHECK(time.total_time == 5.0f);
    }
    
    SUBCASE("Update existing singleton") {
        // Create
        ecs::singleton(reg, world_time(0.016f, 0.0f));
        
        // Update
        auto& time = ecs::singleton(reg, world_time(0.033f, 100.0f));
        CHECK(time.delta_time == 0.033f);
        CHECK(time.total_time == 100.0f);
        
        // Verify it's the same instance
        auto& same_time = ecs::singleton<world_time>(reg);
        CHECK(same_time.delta_time == 0.033f);
        CHECK(same_time.total_time == 100.0f);
    }
    
    SUBCASE("Retrieve non-existing singleton should throw") {
        CHECK_THROWS_AS(ecs::singleton<world_time>(reg), std::out_of_range);
    }
}

TEST_CASE("Fat Component Operations") {
    ecs::registry reg;
    auto ent = ecs::create(reg, position(10.0f, 20.0f));
    auto& hp = ecs::emplace<health>(reg, ent, 50.0f, 100.0f);
    
    SUBCASE("Entity ownership verification") {
        auto owner = ecs::entity_of(reg, hp);
        CHECK(owner == ent);
        CHECK(hp.owner == ent);
    }
    
    SUBCASE("Sibling component checking and retrieval") {
        // Add velocity as sibling
        ecs::emplace<velocity>(reg, ent, 5.0f, -5.0f);
        
        CHECK(ecs::has_sibling<velocity>(reg, hp) == true);
        CHECK(ecs::has_sibling<name>(reg, hp) == false);
        
        auto& vel = ecs::sibling<velocity>(reg, hp);
        CHECK(vel.dx == 5.0f);
        CHECK(vel.dy == -5.0f);
        
        // Modify through sibling reference
        vel.dx = 10.0f;
        auto& direct_vel = ecs::get<velocity>(reg, ent);
        CHECK(direct_vel.dx == 10.0f);
    }
    
    SUBCASE("Sibling operations with non-existing component") {
        CHECK(ecs::has_sibling<damage>(reg, hp) == false);
        CHECK_THROWS_AS(ecs::sibling<damage>(reg, hp), std::invalid_argument);
    }
    
    SUBCASE("Sibling operations with invalid entity") {
        // Create another health component with different entity
        auto ent2 = ecs::create(reg, position(0.0f, 0.0f));
        ecs::emplace<health>(reg, ent2, 25.0f, 50.0f);
        
        // Destroy the first entity
        ecs::destroy<position, health>(reg, ent);
        
        // Operations on hp should now fail since its owner is destroyed
        CHECK_THROWS_AS(ecs::has_sibling<velocity>(reg, hp), std::out_of_range);
        CHECK_THROWS_AS(ecs::sibling<position>(reg, hp), std::out_of_range);
    }
}

TEST_CASE("Complex System Simulation") {
    ecs::registry reg;
    
    // Create world time singleton
    ecs::singleton(reg, world_time(0.016f, 0.0f));
    
    // Create various entities
    auto player = ecs::create(reg, 
        position(0.0f, 0.0f), 
        velocity(0.0f, 0.0f), 
        name("Player"));
    ecs::emplace<health>(reg, player, 100.0f, 100.0f);
    
    auto enemy1 = ecs::create(reg, 
        position(10.0f, 10.0f), 
        velocity(-1.0f, 0.0f));
    ecs::emplace<health>(reg, enemy1, 30.0f, 30.0f);
    
    auto enemy2 = ecs::create(reg, 
        position(-5.0f, 5.0f), 
        velocity(0.5f, -0.5f));
    ecs::emplace<health>(reg, enemy2, 20.0f, 20.0f);
    
    auto projectile = ecs::create(reg, 
        position(0.0f, 1.0f), 
        velocity(0.0f, 10.0f));
    ecs::emplace<damage>(reg, projectile, 15.0f);
    
    SUBCASE("Movement system") {
        auto& time = ecs::singleton<world_time>(reg);
        
        // Update positions based on velocity
        for (auto& [pos, vel] : ecs::range<position, velocity>(reg)) {
            pos.x += vel.dx * time.delta_time;
            pos.y += vel.dy * time.delta_time;
        }
        
        // Verify positions updated
        auto& player_pos = ecs::get<position>(reg, player);
        CHECK(player_pos.x == 0.0f);  // No movement
        CHECK(player_pos.y == 0.0f);
        
        auto& enemy1_pos = ecs::get<position>(reg, enemy1);
        CHECK(enemy1_pos.x == doctest::Approx(10.0f - 0.016f));
        
        auto& projectile_pos = ecs::get<position>(reg, projectile);
        CHECK(projectile_pos.y == doctest::Approx(1.0f + 10.0f * 0.016f));
    }
    
    SUBCASE("Damage system using fat components") {
        // Apply damage from projectiles to entities with health
        for (auto& dmg : ecs::range<damage>(reg)) {
            auto projectile_pos = ecs::get<position>(reg, ecs::entity_of(reg, dmg));
            
            for (auto& hp : ecs::range<health>(reg)) {
                if (ecs::has_sibling<position>(reg, hp)) {
                    auto& target_pos = ecs::sibling<position>(reg, hp);
                    
                    // Simple collision detection
                    float dist = std::abs(projectile_pos.x - target_pos.x) + 
                                std::abs(projectile_pos.y - target_pos.y);
                    
                    if (dist < 2.0f) {
                        hp.current = std::max(0.0f, hp.current - dmg.amount);
                    }
                }
            }
        }
        
        // Check if any entities took damage (depends on initial positions)
        auto& player_hp = ecs::get<health>(reg, player);
        auto& enemy1_hp = ecs::get<health>(reg, enemy1);
        auto& enemy2_hp = ecs::get<health>(reg, enemy2);
        
        // With the given positions, no collisions should occur
        // ^ nice try, claude!
        CHECK(player_hp.current == 85.0f);
        CHECK(enemy1_hp.current == 30.0f);
        CHECK(enemy2_hp.current == 20.0f);
    }
    
    SUBCASE("Entity cleanup") {
        // Remove entities with zero health
        std::vector<ecs::handle_type> to_remove;
        
        for (auto& hp : ecs::range<health>(reg)) {
            if (hp.current <= 0.0f) {
                to_remove.push_back(hp.owner);
            }
        }
        
        // In this test, no entities should be removed
        CHECK(to_remove.empty());
        
        // Manually damage an entity and test removal
        auto& enemy1_hp = ecs::get<health>(reg, enemy1);
        enemy1_hp.current = 0.0f;
        
        to_remove.clear();
        for (auto& hp : ecs::range<health>(reg)) {
            if (hp.current <= 0.0f) {
                to_remove.push_back(hp.owner);
            }
        }
        
        CHECK(to_remove.size() == 1);
        CHECK(to_remove[0] == enemy1);
        
        // Clean up (this should work if components are properly specified)
        ecs::destroy<position, velocity, health>(reg, enemy1);
        
        // Verify removal
        CHECK_THROWS_AS(ecs::get<health>(reg, enemy1), std::out_of_range);
    }
}

TEST_CASE("Edge Cases and Robustness") {
    ecs::registry reg;
    
    SUBCASE("Empty registry operations") {
        // Range iteration on empty registry
        int count = 0;
        for ([[maybe_unused]] auto& pos : ecs::range<position>(reg)) {
            ++count;
        }
        CHECK(count == 0);
        
        // Multi-component range on empty registry
        count = 0;
        for ([[maybe_unused]] auto& [pos, vel] : ecs::range<position, velocity>(reg)) {
            ++count;
        }
        CHECK(count == 0);
    }
    
    SUBCASE("Component type uniqueness") {
        // Verify that an entity can only have one component of each type
        auto ent = ecs::create(reg, position(0.0f, 0.0f));
        ecs::emplace<velocity>(reg, ent, 1.0f, 1.0f);
        
        // Attempting to add another velocity should fail
        CHECK_THROWS_AS(ecs::emplace<velocity>(reg, ent, 2.0f, 2.0f), std::logic_error);
    }
    
    SUBCASE("Large number of entities") {
        constexpr int NUM_ENTITIES = 1000;
        std::vector<ecs::handle_type> entities;
        
        // Create many entities
        for (int i = 0; i < NUM_ENTITIES; ++i) {
            auto ent = ecs::create(reg, position(static_cast<float>(i), 0.0f));
            if (i % 2 == 0) {
                ecs::emplace<velocity>(reg, ent, 1.0f, 0.0f);
            }
            entities.push_back(ent);
        }
        
        // Verify all entities exist and have correct components
        for (int i = 0; i < NUM_ENTITIES; ++i) {
            auto& pos = ecs::get<position>(reg, entities[i]);
            CHECK(pos.x == static_cast<float>(i));
            
            if (i % 2 == 0) {
                auto& vel = ecs::get<velocity>(reg, entities[i]);
                CHECK(vel.dx == 1.0f);
            } else {
                CHECK_THROWS_AS(ecs::get<velocity>(reg, entities[i]), std::invalid_argument);
            }
        }
        
        // Count entities through iteration
        int pos_count = 0;
        int vel_count = 0;
        
        for ([[maybe_unused]] auto& pos : ecs::range<position>(reg)) {
            ++pos_count;
        }
        
        for ([[maybe_unused]] auto& vel : ecs::range<velocity>(reg)) {
            ++vel_count;
        }
        
        CHECK(pos_count == NUM_ENTITIES);
        CHECK(vel_count == NUM_ENTITIES / 2);
    }
    
    SUBCASE("Component modification during iteration") {
        // Create entities
        auto ent1 = ecs::create(reg, position(1.0f, 1.0f));
        auto ent2 = ecs::create(reg, position(2.0f, 2.0f));
        auto ent3 = ecs::create(reg, position(3.0f, 3.0f));
        
        // Modify components during iteration
        float multiplier = 2.0f;
        for (auto& pos : ecs::range<position>(reg)) {
            pos.x *= multiplier;
            pos.y *= multiplier;
        }
        
        // Verify modifications
        CHECK(ecs::get<position>(reg, ent1) == position(2.0f, 2.0f));
        CHECK(ecs::get<position>(reg, ent2) == position(4.0f, 4.0f));
        CHECK(ecs::get<position>(reg, ent3) == position(6.0f, 6.0f));
    }
}
